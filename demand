需求:
一、任务：
实现一个帮助进行地铁出行路线规划的命令行程序。

要求：
1. 使用Visual Studio Community 2019 或 IDEA 进行开发，采用C++, C# 或 Java 语言实现，运行环境为64-bit Windows 10。
2. 提交的代码要求经过Code Quality Analysis工具的分析并消除所有的警告。Code Quality Analysis工具的用法参见：
http://msdn.microsoft.com/en-us/library/dd264897.aspx
3. 请使用性能分析工具来找出代码中的性能瓶颈并进行改进。
4. 写出至少10个测试用例确保你的程序能够正确处理各种情况。
5. 使用Github来管理源代码和测试用例。

作业提交：

在个人博客上发布项目源代码的Github链接，以便老师下载，老师将会在测试环境中检查程序的正确性。
正确的程序会再进行性能测试，根据性能的好坏进行评分；不正确的程序没有性能的分数。
撰写一个博客，要求参见博客作业要求。


二、实现一个能处理正确输入的命令行的计算地铁线路最短路径的程序
     要求实现一个能够计算地铁线路最短路径的程序，为了降低难度与简化要求，现阶段我们可以假定程序的输入一定是正确的。同时，为了让地铁程序能与地铁线路图解耦，我们需要将地铁线路与程序分离开，将其保存成一个可读入的文件。

具体地，我们要将图1的地铁线路信息等用一个文本文件（假设名字叫 subway.txt）的形式保存起来，应保存的信息应包括地铁线路名称、各个地铁站点的名称以及车站换乘信息，使得应用程序可以通过读取这个文件，就能掌握关于北京地铁线路的所有信息。

在开始设计程序之前，请先思考并设计一种文件格式用于存储地铁信息。一方面，这种文件格式要简洁易懂，可以灵活扩展，另一方面它又要方便应用程度读取。请在博客中给出你定义的文件格式的前5行，并以它为例简要说明它的设计理念。

用于测试的地铁图如图1所示。为了简单起见，所有暂缓开通的站点都认定为已经开通。图片中所有背景为黑框的站点都是可以换乘的站点。每一条地铁线的起点如下：

地铁线路名称	起始站点
1号线	刘园
2号线	曹庄
3号线	小淀
5号线	北辰科技园北
6号线	南孙庄
9号线	天津站
需求1：
请各对同学实现一个支持显示地铁线路与计算换乘的程序（对于C++/C#，编译后的二进制文件名需为 subway.exe；对于Java项目，Main方法所在文件名需为 subway.java）。之后，用户可以通过命令行启动这个程序。程序在启动时，会读取不同命令对应的命令行参数。对于地铁线路信息图，我们约定它采用参数 -map 作为标志。程序启动时需要通过读取 -map 参数来获得对应的自定义地铁文件（命名为 subway.txt），从而得到地铁线路图的信息。一个调用应用程序的示例如下：

subway.exe -map subway.txt
对于 Java 语言，则是

java subway -map subway.txt
需求2：

现在程序里已经与地铁文件解耦了，那么我们就可以在这个的基础上做一些基础的查询操作。比如说，用户希望查询指定地铁线经过的站点。这样，在应用程序需要支持一个新的命令行参数 -a，它指定了用户希望查询的地铁线路。这样，在给定地铁线路时，你的程序就需要能够从线路的起始站点开始，依次输出该地铁线经过的所有站点，直到终点站。输出的文件我们使用 -o 命令行参数来指定。一个调用应用程序的示例如下：

subway.exe -a 1号线 -map subway.txt -o station.txt
对于 Java 语言，则是

java subway -a 1号线 -map subway.txt -o station.txt
需求3：

如果用户希望坐地铁，他希望能通过最少的站数从出发点到达目的地，这样就可以在命令行中以 -b 参数加两个地铁站点名称分别作为出发与目的，比如用户希望知道 洪湖里 到复兴路 之间的最短路线是怎样的，他就可以使用如下命令让程序将结果写入 routine.txt 中。

subway.exe -b 洪湖里 复兴路 -map subway.txt -o routine.txt
你的程序将计算从出发到目的站点之间的最短（经过的站点数最少）路线，并输出经过的站点的个数和路径（包括出发与目的站点）。注意，如果需要换乘，请在换乘站的下一行输出换乘的线路。上面样例的输出就会存入 routine.txt 文件中，文件内容如下：

3
洪湖里
西站
6号线
复兴路
值得注意的是，请严格按照要求输出，不要增加任何额外输出或提示语。

若各位在开发中遇到了困难，如缺少思路等，请先以伪代码的形式，将程序按功能拆分为模块，并描述一下各个模块的功能和操作流程，并在博客中附上伪码，随后根据伪码进一步编程